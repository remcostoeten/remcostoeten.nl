---
title: Drizzleasy
description: Ultra-simple, type-safe CRUD operations for Next.js with Drizzle ORM. Build database operations with full TypeScript support and IntelliSense.
keywords: [crud, drizzle, orm, typescript, nextjs, database, type-safe, sql, drizzleasy]
author: Remco Stoeten
category: Database
tags: [crud, typescript, drizzle, nextjs, drizzleasy]
---

# Drizzleasy

Ultra-simple, type-safe CRUD operations for Next.js with Drizzle ORM. Build database operations with full TypeScript support, IntelliSense, and error handling.

## Features

- üîí **Type-safe operations** - Full TypeScript support with generics
- üöÄ **Fluent API** - Clean, chainable interface
- üõ°Ô∏è **Built-in error handling** - Consistent error responses
- üìù **IntelliSense support** - Complete autocomplete and hover documentation
- ‚ö° **Multiple databases** - PostgreSQL, MySQL, SQLite, Turso support
- üéØ **Optimistic updates** - Client-side React hooks included
- üì¶ **Dual module support** - Works with both ESM and CommonJS
- üîÑ **Auto-detection** - Automatically detects database type from connection string

## Quick Start

### Installation

```bash
npm install @remcostoeten/drizzleasy
```

### Auto-Configuration (Recommended)

```typescript
import { initializeConnection } from '@remcostoeten/drizzleasy'

// Auto-detects database type and loads schema
const db = await initializeConnection(process.env.DATABASE_URL!)

// For Turso with auth token
const db = await initializeConnection(process.env.DATABASE_URL!, {
  authToken: process.env.TURSO_AUTH_TOKEN
})

// Environment-based switching
const db = await initializeConnection({
  development: 'file:./dev.db',
  production: process.env.DATABASE_URL!
})
```

### Manual Configuration

```typescript
import { configure } from '@remcostoeten/drizzleasy'
import { db } from './db'
import * as schema from './schema'

// Configure once in your app
configure(db, schema)
```

### Basic Usage

```typescript
import { readFn, createFn, updateFn, destroyFn } from '@remcostoeten/drizzleasy'

type User = {
  id: string
  name: string
  email: string
  age: number
  status: 'active' | 'inactive'
  role: 'admin' | 'user'
}

// Create factory functions
const read = readFn<User>()
const create = createFn<User>()
const update = updateFn<User>()
const destroy = destroyFn<User>()

// Create
const { data, error } = await create('users')({ 
  name: 'John', 
  email: 'john@example.com',
  age: 25,
  status: 'active',
  role: 'user'
})

// Read all records
const { data: users } = await read('users')()

// Simple WHERE conditions
const { data: activeUsers } = await read('users')
  .where({ status: 'active' })
  .execute()

// Advanced filtering
const { data: results } = await read('users')
  .where({ age: '>18' })              // Greater than 18
  .where({ name: '*john*' })          // Contains 'john'
  .where({ role: ['admin', 'user'] }) // IN array
  .execute()

// Read by ID
const { data: user } = await read('users').byId('123')

// Update
await update('users')('123', { name: 'Jane' })

// Delete
await destroy('users')('123')
```

## Simple WHERE Syntax

Intuitive filtering with natural operators:

```typescript
type Product = {
  id: string
  name: string
  price: number
  category: string
  inStock: boolean
  rating: number
}

const read = readFn<Product>()

// Comparison operators
const { data: affordableProducts } = await read('products')
  .where({ price: '<100' })        // Less than 100
  .where({ rating: '>=4.0' })      // 4 stars or higher
  .execute()

// String matching
const { data: searchResults } = await read('products')
  .where({ name: '*laptop*' })     // Contains 'laptop'
  .where({ category: 'electronics*' }) // Starts with 'electronics'
  .execute()

// Array matching (IN operator)
const { data: categoryProducts } = await read('products')
  .where({ category: ['books', 'electronics', 'clothing'] })
  .execute()

// Not equal
const { data: availableProducts } = await read('products')
  .where({ category: '!discontinued' }) // Not discontinued
  .execute()
```

## All WHERE Operators

Complete reference for filtering conditions:

```typescript
// Direct equality
{ status: 'active' }           // Exact match
{ isActive: true }             // Boolean values
{ count: 0 }                   // Number values

// Comparison (numbers, strings, dates)
{ age: '>18' }                 // Greater than
{ age: '>=21' }                // Greater than or equal
{ price: '<100' }              // Less than
{ rating: '<=4.5' }            // Less than or equal
{ status: '!inactive' }        // Not equal

// String patterns
{ name: '*john*' }             // Contains 'john'
{ name: 'john*' }              // Starts with 'john'
{ email: '*@gmail.com' }       // Ends with '@gmail.com'

// Array matching (IN operator)
{ role: ['admin', 'user'] }    // Match any value in array
{ category: ['books', 'tech'] } // Multiple categories
```

## Error Handling

All operations return a consistent result format:

```typescript
const create = createFn<User>()
const { data, error } = await create('users')({ name: 'John' })

if (error) {
  console.error('Operation failed:', error.message)
  return
}

console.log('Success:', data)
```

## Client-Side Hooks

Optimistic updates for React applications:

```typescript
'use client'
import { useOptimisticCrud, createFn } from '@remcostoeten/drizzleasy'

function UserList({ initialUsers }) {
  const { data, isPending, optimisticCreate } = useOptimisticCrud(initialUsers)
  const create = createFn<User>()
  
  const handleCreate = (userData) => {
    optimisticCreate(userData, () => create('users')(userData))
  }
  
  return (
    <div>
      {data.map(user => <div key={user.id}>{user.name}</div>)}
      {isPending && <div>Creating...</div>}
    </div>
  )
}
```

## Database Support

Drizzleasy supports multiple database providers with auto-detection:

### PostgreSQL
```typescript
// Local PostgreSQL
const db = await initializeConnection('postgresql://user:pass@localhost:5432/mydb')

// Cloud PostgreSQL (Neon, Supabase, etc.)
const db = await initializeConnection(process.env.DATABASE_URL!)
```

### SQLite
```typescript
// File-based SQLite
const db = await initializeConnection('file:./database.db')

// In-memory SQLite
const db = await initializeConnection('file::memory:')
```

### Turso (LibSQL)
```typescript
const db = await initializeConnection(process.env.DATABASE_URL!, {
  authToken: process.env.TURSO_AUTH_TOKEN
})
```

## Module Support

Works with both ESM and CommonJS:

```typescript
// ESM (recommended)
import { readFn, createFn, updateFn, destroyFn, initializeConnection } from '@remcostoeten/drizzleasy'

// CommonJS
const { readFn, createFn, updateFn, destroyFn, initializeConnection } = require('@remcostoeten/drizzleasy')
```

## Next Steps

- [API Reference](/api-reference) - Complete API documentation
- [Examples](/examples) - Real-world usage examples
